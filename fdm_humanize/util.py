"""
Utils to open tar files and deal with the file structure generated by the FDM one-click log utility.
"""

import tarfile
import logging

log = logging.getLogger(__name__)
logging.basicConfig(level=logging.DEBUG)


def get_sub_dicts_with_key_and_not_value(d, key, value):
    # Create an empty list to store the sub-dictionaries
    sub_dicts = []

    # before recursion, if the current dictionary has the key and the value is not the one we are looking for,
    # add it to the list\

    # Define a recursive function that gets the sub-dictionaries
    def get_sub_dicts(d):
        if key in d and d[key] != value and d not in sub_dicts:
            sub_dicts.append(d)
        # Iterate over the items in the dictionary
        for k, v in d.items():
            # If the value is a dictionary and it contains the key
            # with the specified value, append it to the list of sub-dictionaries
            if isinstance(v, dict) and key in v and v[key] != value:
                sub_dicts.append(v)

            # If the value is a dictionary, call the function recursively
            # to get the sub-dictionaries of the nested dictionary
            if isinstance(v, dict):
                get_sub_dicts(v)

            if isinstance(v, list):
                for item in v:
                    if isinstance(item, dict):
                        get_sub_dicts(item)

    # Call the recursive function to get the sub-dictionaries
    get_sub_dicts(d)

    # Return the list of sub-dictionaries
    return sub_dicts


def extract_from_tar_file(filepath: str, file_names: str | list[str], destination: str):
    """Extract a file from a list of file objects"""
    if isinstance(file_names, str):
        file_names = [file_names]
    tar = tarfile.open(filepath)
    tar.extractall(members=[f for f in tar.getmembers() if f.name in file_names], path=destination)



def json_to_html(json_dict):
    indent_level = 0
    html_string = ""
    current_group = []
    current_sub_group = 0

    # Recursively process each key-value pair in the dictionary
    def process_dict(d):
        nonlocal indent_level, html_string, current_group, current_sub_group
        for key, value in d.items():
            if key == "History" and isinstance(value, list):
                indent_level += 1
                # hide the elements of the history list by default
                toggle_element_html = "<div style='margin-left: {}px; border-left: 2px solid #333; padding-left: 10px; border-top: 1px solid #333; background-color: {}' onclick='this.nextElementSibling.style.display = (this.nextElementSibling.style.display === \"block\") ? \"none\" : \"block\"'>{}: {{</div>".format(
                    indent_level * 20, "#f5f5f5" if current_sub_group % 2 == 0 else "#e8e8e8", key)
                html_string += toggle_element_html
                html_string += "<div style='display: none'>"
                for sub_dict in value:
                    process_dict(sub_dict)
                html_string += "</div>"
                indent_level -= 1

            # If the value is a dictionary, increase the indent level and recursively process the dictionary
            elif isinstance(value, dict):
                indent_level += 1
                current_group.append(key)
                current_sub_group += 1
                # Extract the HTML string for the clickable element
                toggle_element_html = "<div style='margin-left: {}px; border-left: 2px solid #333; padding-left: 10px; border-top: 1px solid #333; background-color: {}' onclick='this.nextElementSibling.style.display = (this.nextElementSibling.style.display === \"block\") ? \"none\" : \"block\"'>{}: {{</div>".format(
                    indent_level * 20, "#f5f5f5" if current_sub_group % 2 == 0 else "#e8e8e8", key)
                # Extract the HTML string for the sub-dictionary
                sub_dict_html = "<div style='display: none'>"
                process_dict(value)
                sub_dict_html += "}}</div>"
                indent_level -= 1
                current_group.pop()
                current_sub_group -= 1
                # Add the HTML strings to the main HTML string
                html_string += toggle_element_html + sub_dict_html
            # If the value is a list, increase the indent level and recursively process each item in the list
            elif isinstance(value, list):
                indent_level += 1
                current_group.append(key)
                current_sub_group += 1
                # Extract the HTML string for the list
                list_html = "<div style='margin-left: {}px; border-left: 2px solid #333; padding-left: 10px; border-top: 1px solid #333; background-color: {}'>{}: [".format(
                    indent_level * 20, "#f5f5f5" if current_sub_group % 2 == 0 else "#e8e8e8", key)
                for i, item in enumerate(value):
                    if isinstance(item, dict):
                        process_dict(item)
                    else:
                        list_html += "<div style='margin-left: {}px; border-left: 2px solid #333; padding-left: 10px; border-top: 1px solid #333; background-color: {}'>{}: {}</div>".format(
                            (indent_level + 1) * 20, "#f5f5f5" if current_sub_group % 2 == 0 else "#e8e8e8", i, item)
                list_html += "]</div>"
                indent_level -= 1
                current_group.pop()
                current_sub_group -= 1
                # Add the HTML string to the main HTML string
                html_string += list_html
            # If the value is a string, add it to the HTML string
            else:
                html_string += "<div style='margin-left: {}px; border-left: 2px solid #333; padding-left: 10px; border-top: 1px solid #333; background-color: {}'>{}: {}</div>".format(
                    (indent_level + 1) * 20, "#f5f5f5" if current_sub_group % 2 == 0 else "#e8e8e8", key, value)

    process_dict(json_dict)

    return html_string
